# Geoms {#sec-geoms}

```{r}
#| echo: false
#| message: false
#| results: asis
source("warning.R")
```

```{r}
#| echo: false
#| message: false
#| warning: false

library(conflicted)
conflicts_prefer(dplyr::filter)
```

A **geom** (short for geometric object) is a component that defines how data is visually represented in a plot. Geoms determine the type of visualization or the graphical shape that will be drawn.

"These geoms are the fundamental building blocks of **ggplot2** [@wickham2024a]. They are useful in their own right, but are also used to construct more complex geoms. Most of these geoms are associated with a named \[chart\]: when that geom is used by itself in a \[chart\], that \[chart\] has a special name." [@wickham2016]

ggplot2 already has a [long list of geoms](https://ggplot2.tidyverse.org/reference/index.html#geoms). We won't be discussing those unless there is an extension package that is an improvement to the original. Primarily, this chapter focuses on the geoms that ggplot2 does not include.

## Area charts {#sec-area-charts}

Area charts are based on line charts. The area between the x-axis and each line (or the area between lines) is shaded to help highlight the volume of the data.

In this chapter, we'll take a look at the __horizon chart__, an improved version of the __ribbon chart__, and the __streamgraph__. They are all different takes on the area chart.

### Horizon chart {#sec-horizon-chart}

A horizon chart is a method for condensing time series data into a format that is both informative and relatively easy to interpret.

Often, when you have both positive and negative values, they lie on both sides of the x-axis. In a horizon chart, the negative values are on the same side as the positive ones.

We use color to show whether the values are positive or negative. But also for the magnitude of those values.

As Jonathan Schwabish points out in their book, Better Data Visualizations [@schwabish2021], "the purpose of the horizon chart is not necessarily to enable readers to pick out specific values, but instead to easily spot general trends and identify extreme values".

For the horizon chart, we'll be using __ggHoriPlot__ [@rivas-gonzalez2022]. The package includes various example data sets. But we'll be using weather data from the __Finnish Meteorological Institute__ (FMI). Its open data, weather observations are licensed under [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/).

```{r}
#| echo:    false
#| message: false
#| warning: false
#| results: asis

library(readr)

temperature_hki <- read_csv("data/temperature_hki-2025-06-13.csv")
```

Using the [FMI API](https://en.ilmatieteenlaitos.fi/open-data) (Application Programming Interface), I retrieved the average temperatures in __Helsinki__ (Kaisaniemi weather station) for the years 2000-2024. You can take a look at the data below.

```{r}
#| echo:    false
#| message: false
#| warning: false
#| results: asis

library(dplyr)
library(rmarkdown)

temperature_hki %>%
  paged_table()
```

We have __avg_temperature_celsius__ (daily average temperature (in Celsius)), __day__, __month__, and __year__. We also have the __date_dummy__ column. It is there because we want to use the month as the x-axis. But the column needs to be in _date_ format for our use case. So we need all the rows to have the same dummy year with real months and days. I chose 2024 because it was a leap year. Without it, all the rows with February 29th would have _NA_ in that column instead of the correct values.

Before we can proceed with the visualization, we need to perform some data wrangling. First, we’ll remove outliers using the [interquartile range (IQR) method](https://en.wikipedia.org/wiki/Interquartile_range).

```{r}
#| message: false
#| warning: false
#| results: asis

library(dplyr)

# Filter temperature data to exclude outliers based on 1.5 * IQR method
cutpoints <- temperature_hki %>%
  filter(
    between(
      avg_temperature_celsius,
      quantile(
        avg_temperature_celsius, 0.25, na.rm = TRUE
        ) - 1.5 * IQR(avg_temperature_celsius, na.rm = TRUE),
      quantile(
        avg_temperature_celsius, 0.75, na.rm = TRUE
        ) + 1.5 * IQR(avg_temperature_celsius, na.rm = TRUE)
    )
  )
```

```{r}
#| echo:    false
#| message: false
#| warning: false
#| results: asis

cutpoints %>%
  paged_table()
```

Fifteen outliers were filtered out, and we can continue. Next, we’ll calculate the midpoint of the temperature range and also divide the __scale__ into evenly spaced value ranges. We’ll use the first as the __origin__ for the horizon chart and the second to determine how to color the areas.

```{r}
#| message: false
#| warning: false
#| results: asis

# Calculate the midpoint of the temperature range for use in horizon chart
origin <- cutpoints %>%
  summarize(origin = mean(range(avg_temperature_celsius))) %>% 
  pull(origin)

# Create the scale vector:
# 7 evenly spaced values across the filtered temperature range.
# Drop the 4th value (the midpoint), as required by gghoriplot scale input
scale <- cutpoints %>%
  summarize(
    min_val = min(avg_temperature_celsius),
    max_val = max(avg_temperature_celsius)
  ) %>%
  # Generate 7 evenly spaced values
  with(seq(min_val, max_val, length.out = 7)) %>% 
  # Convert to tibble to use dplyr::slice()
  tibble() %>%
  # Remove the middle value (4th out of 7)
  slice(-4) %>% 
  # Return as plain numeric vector
  pull(.)
```

```{r}
#| echo:    false
#| message: false
#| warning: false

# The origin
.origin <- round(origin, 2)

# The horizon scale cutpoints
.scale <- round(scale, 2)
```

The origin is `r .origin`, and the scale cutpoints are as follows: `r .scale`.

Now we’re ready for the visualization itself. Besides ggHoriPlot and ggplot2, we’ll be using __ggthemes__ [@arnold2024] to provide us the theme. We'll dive deeper into _themes_ (including ggthemes in @sec-ggthemes) later on in @sec-themes.

We're using `geom_horizon()` to create the horizon chart. The arguments to pay attention to are __fill__ (inside `aes()`), __origin__, and __horizonscale__. They are all using the origin and scale we calculated earlier. `scale_fill_hcl()` is also available in the ggHoriPlot package. Otherwise, we’re using basic ggplot2 functionalities.

```{r}
#| message: false
#| warning: false
#| results: asis

library(ggHoriPlot) # for geom_horizon() to create horizon plots
library(ggplot2)    # for general plotting functions
library(ggthemes)   # for additional themes like theme_few()

# Create the horizon chart
temperature_hki %>%
  ggplot() +
  
  # Horizon chart layer, mapping x, y, and fill aesthetics
  geom_horizon(
    aes(
      date_dummy,              # x-axis: typically date
      avg_temperature_celsius, # y-axis: temperature variable
      fill = ..Cutpoints..     # fill determined by horizon chart cutpoints
    ), 
    origin       = origin, # baseline (e.g., 0°C); defines neutral midpoint
    horizonscale = scale   # vertical scale; controls how bands are split
  ) +

  # Use a diverging color scale (red-blue), reversed so red = high temp
  scale_fill_hcl(palette = 'RdBu', reverse = TRUE) +

  # Create one small horizon chart per year, stacked vertically
  facet_grid(vars(year)) +

  # Use a clean, simple theme based on the rules and examples from Stephen
  # Few's Show Me the Numbers and Practical Rules for Using Color in Charts
  theme_few() +

  # Customize appearance
  theme(
    # Customize x-axis labels
    axis.text.x     = element_text(size = 10),
    # Remove unnecessary labels
    axis.text.y     = element_blank(),                   
    axis.title.y    = element_blank(),                   
    axis.ticks.y    = element_blank(),                   
    panel.border    = element_blank(),                   
    # Remove vertical space between facets
    panel.spacing.y = unit(0, "lines"),                  
    # Subtle caption style
    plot.caption    = element_text(size = 8, hjust = 0, color = "#777777"),
    # Adjust margins because otherwise Jan is too close to the left edge
    plot.margin     = margin(10, 10, 10, 15),             
    # Customize facet labels
    strip.text.y    = element_text(size = 8, angle = 0, hjust = 0)  
  ) +

  # Format x-axis to show months (with short names) without expansion
  scale_x_date(
    expand      = c(0, 0),
    date_breaks = "1 month", 
    date_labels = "%b"
  ) +

  # Add informative plot title, subtitle, and data source caption
  labs(
    title    = "Average daily temperature (Celsius) in Helsinki",
    subtitle = "From 2000 to 2024",
    caption  = "Data: Finnish Meteorological Institute open data, weather observations (CC BY 4.0)",
    x        = NULL # remove x-axis title
  )
```

I'm not a climatologist, but it does seem like there is a trend, over time, of Helsinki having milder winters. The summer temperatures are less clear-cut and will need a closer look.

### Ribbon chart (improved) {#sec-ribbon-chart-improved}

As the ggplot2 documentation tells us, an area chart is, in fact, a special case of a ribbon chart. That makes sense when you realize that every type of area chart has a __ymin__ and __ymax__. In the basic area chart, ymin is zero, and ymax is __y__. [@wickham2024a]

The ribbon chart, then, displays the area between two lines. `geom_ribbon()` gets the job done when the lines don’t meet. But as you’ll soon see, for those cases where they do, you need something called _braiding_. You can read more about it in the __ggbraid__ [@grantham2025] [documentation](https://nsgrantham.github.io/ggbraid/articles/temps.html#the-unbraided-ribbon-problem).

We’ll take a look at what the problem (and solution) looks like with real data. But let’s first examine the data we’ll be using for this. Time series data works best for this type of chart. Let’s stick to the **ggplot2movies** [@wickham2015] data set that we first encountered in @sec-imdb-movies-1893-2005 and the __movies_na__ tibble.

```{r}
#| message: false
#| warning: false
#| echo:    false

library(ggplot2movies)

movies_na <- movies %>%
  mutate(
    # Turn all blank values of the character type into NA
    across(where(is.character), ~na_if(., "")), 
    # Create a decade column for grouping based on the values in the year column
    decade = floor(year / 10) * 10
  )
```

We’ll perform some transformations to prepare the data for visualization. In this case, we’ll need the data in two _formats_, __long__ and __short__.

Let's first create the _long_ tibble consisting of __genre__, __year__, and __n__ (for the count).

One minor detail to note here is that we’ll turn the genre column from _character_ to _factor_ format. We’ll use __forcats__ [@wickham2023h] from __tidyverse__ [@wickham2023b] to do that. It's not necessary in this case, but it's good practice.

```{r}
#| message: false
#| warning: false

library(forcats)
library(tidyr)

# Transform and filter the `movies_na` dataset
movies_na_long <- movies_na %>%
  
  # Pivot genre columns (from Action to Short) into long format:
  # Creates two columns: "genre" and "value"
  pivot_longer(Action:Short, names_to = "genre") %>%
  
  # Filter to keep only:
  # - rows where the movie is flagged in that genre (value != 0)
  # - only the genres Comedy and Drama
  # - movies released between 1900 and 2000
  filter(
    value != 0,
    genre %in% c("Comedy", "Drama"),
    between(year, 1900, 2000)
  ) %>%
  
  # Convert genre to a factor
  mutate(genre = as_factor(genre)) %>%
  
  # Count the number of movies per genre per year
  count(genre, year)
```

```{r}
#| echo:    false
#| message: false
#| warning: false
#| results: asis

movies_na_long %>% 
  paged_table()
```

Next, we’ll split the genre into two separate columns, Comedy and Drama. They will retrieve their values from the n column.

We’ll also be adding a __fill_condition__ column. We’ll use that later to determine which color to use to fill the area between the two lines.

```{r}
#| message: false
#| warning: false

# Convert long-format genre counts back to wide format and compare values
movies_na_wide <- movies_na_long %>%
  
  # Pivot genre counts from long to wide:
  # Each genre becomes its own column (e.g., Comedy, Drama),
  # with yearly counts as values
  pivot_wider(
    names_from  = genre,
    values_from = n
  ) %>%
  
  # Create a new logical column indicating whether
  # Comedy had fewer movies than Drama in that year
  mutate(fill_condition = Comedy < Drama)
```

```{r}
#| echo:    false
#| message: false
#| warning: false
#| results: asis

movies_na_wide %>% 
  paged_table()
```

Now we can return to the topic of why we need to use an extension for cases where the lines don’t stay separate.

Here’s what the basic visualization would look like with `geom_ribbon()` from ggplot2.

```{r}
#| message: false
#| warning: false

ggplot() +
  geom_line(
    aes(year, n, linetype = genre),
    data = movies_na_long
  ) +
  geom_ribbon(
    aes(year, ymin = Comedy, ymax = Drama, fill = fill_condition),
    data  = movies_na_wide,
    alpha = 0.7
  )
```

That won't work if we want to use the ribbon chart to show where the two categories change places, indicating which is greater.

But that's where ggbraid's `geom_braid()` comes to the rescue. The basic code is the same. We'll only switch the geom function.

The rest of the code is to make the visualization more presentable. Note that we'll move the legend inside the plot. We'll use the __legend.position__ argument inside the `theme()` function to do that. There's enough _white space_ inside the plot to accommodate the legend. This way, we gain more space to showcase the time series element of the plot.

```{r}
#| message: false
#| warning: false

library(ggbraid) # for geom_braid() to visualize overlapping time series

ggplot() +
  
  # Line plot for number of movies per genre per year
  geom_line(
    aes(year, n, linetype = genre),
    data = movies_na_long
  ) +
  
  # Braid layer to highlight which genre had more movies per year
  geom_braid(
    aes(year, ymin = Comedy, ymax = Drama, fill = fill_condition),
    data  = movies_na_wide,
    alpha = 0.7
  ) +
  
  # Text annotation when comedies dominated
  annotate(
    "text",
    x     = 1938,
    y     = 300,
    size  = 4,
    label = "More comedies than drama",
    hjust = 0.5,
    color = "#F36523"
  ) +
  
  # Text annotation when dramas dominated
  annotate(
    "text",
    x     = 1975,
    y     = 80,
    size  = 4,
    label = "More drama than comedies",
    hjust = 0.5,
    color = "#125184"
  ) +
  
  # Manually set fill colors for the braid based on fill condition
  scale_fill_manual(values = c("#F36523", "#125184")) +
  
  # Customize x-axis: limit, spacing, and ticks
  scale_x_continuous(
    expand = c(0, 1),
    limits = c(1899, 2001),
    breaks = seq(1900, 2000, by = 10)
  ) +
  
  # Customize y-axis: limit, spacing, and ticks
  scale_y_continuous(
    expand = c(0, 1),
    limits = c(0, 800),
    breaks = seq(0, 800, by = 100)
  ) +
  
  # Hide fill legend (keep linetype legend only)
  guides(fill = "none") +
  
  # Add plot title, subtitle, and axis labels
  labs(
    linetype = NULL,
    title    = "100 years of cinema",
    subtitle = "Number of comedies vs. dramas throughout the years",
    x        = NULL,
    y        = NULL
  ) +
  
  # Use a clean black-and-white theme as a base
  theme_bw() +
  
  # Custom legend appearance and positioning
  theme(
    legend.direction = "horizontal",
    legend.box.background = element_rect(
      color     = "black",
      linetype  = "solid",
      linewidth = 0.5
      ),
    legend.key.size  = unit(2, "line"),
    legend.position  = c(0.19, 0.88), # relative position inside plot
    legend.text      = element_text(size = 10)
  )
```

I'm not an expert, but based on this data set there would seem to be a correlation between major wars (WWI, WWII, and the Vietnam War) and more comedies being made.

As an extra, we'll take a look at another ribbon chart. We can use the data set from @sec-horizon-chart, which contains average daily temperatures in Helsinki from 2000 to 2024. We'll compare the two years, 2000 and 2024. Which had more warmer days?

First, we’ll perform similar transformations and get the data into both long and wide formats.

One minor detail to note here is that we’ll need to turn the year column from _numeric_ to _factor_ format. It won’t work as a category for the linetype argument otherwise. We’ll again use the forcats package to do that.

```{r}
#| message: false
#| warning: false

temperature_hki_long <- temperature_hki %>%
  
  # Filter data to include only the years 2000 and 2024
  filter(year %in% c(2000, 2024)) %>%
  
  # Convert `year` to a factor (useful for plotting or grouping)
  mutate(year = as_factor(year)) %>%
  
  # Keep only the necessary columns for analysis or visualization
  select(avg_temperature_celsius, year, date_dummy)
```

In this next transformation, note the use of the __names_prefix__ argument. A column with a number as the first character of the name is not ideal. This will take care of that.

```{r}
#| message: false
#| warning: false

# Pivot data from long to wide format
temperature_hki_wide <- temperature_hki_long %>%
  
  # Creates one column per year (e.g., year_2000, year_2024),
  # using temperature values as the content
  pivot_wider(
    names_from   = year,
    names_prefix = "year_",
    values_from  = avg_temperature_celsius
  ) %>%
  
  # Create a new logical column to compare the two years:
  # TRUE if 2024 temp > 2000 temp for that date
  mutate(fill_condition = year_2000 < year_2024)
```

We’ll also count the number (and percentage of total) of days where the average temperature is greater in 2000 and 2024. We’ll use this information for annotations.

```{r}
#| message: false
#| warning: false

temperature_hki_wide %>%
  
  # Count how many days had each condition (TRUE/FALSE)
  count(fill_condition) %>%
  
  # Calculate the percentage for each group
  mutate(n_pct = round(n / sum(n), 3))
```

Looks like 2024 has more days (60.4%) that were, on average, warmer than 2000 (39.6%).

The visualization itself is like the movie example. The most significant difference is the use of two packages from the tidyverse family.

`str_glue()` from __stringr__ [@wickham2023g] features a convenient implicit line break functionality. We’ll also use it to add the degree Celsius symbol (°C) to the y-axis.

`as_date()` from __lubridate__ [@spinu2024] allows us to use the date in _character_ format to map it to the x-axis. This helps us place the annotations in the correct position.

```{r}
#| message: false
#| warning: false

library(ggbraid)   # for geom_braid(), visualizing area between two lines
library(lubridate) # for working with date types
library(stringr)   # for string manipulation like str_glue()

ggplot() +
  
  # Add temperature lines for each year (2000 and 2024)
  geom_line(
    aes(date_dummy, avg_temperature_celsius, linetype = year),
    data = temperature_hki_long
  ) +
  
  # Add braided area showing difference between 2000 and 2024
  # Fill based on which year was warmer (fill_condition)
  geom_braid(
    aes(
      date_dummy,
      ymin = year_2000,
      ymax = year_2024,
      fill = fill_condition
    ),
    data  = temperature_hki_wide,
    alpha = 0.7
  ) +
  
  # Annotate area where 2000 was warmer
  annotate(
    "text",
    x     = as_date("2024-03-01"),
    y     = -17.5,
    size  = 4,
    label = str_glue(
      "2000 was warmer
      40 % of the days"
    ),
    hjust = 0.5,
    color = "#125184"
  ) +
  
  # Annotate area where 2024 was warmer
  annotate(
    "text",
    x     = as_date("2024-11-15"),
    y     = 17.5,
    size  = 4,
    label = str_glue(
      "2024 was warmer 
      60 % of the days"
    ),
    hjust = 0.5,
    color = "#F36523"
  ) +
  
  # Manual fill colors: blue for 2000 warmer, orange for 2024 warmer
  scale_fill_manual(values = c("#125184", "#F36523")) +
  
  # Format x-axis: monthly ticks, short month labels
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b",
    expand      = c(0, 0.1)
  ) +
  
  # Format y-axis: show temperature with °C symbol
  scale_y_continuous(labels = ~ str_glue("{.x} °C")) +
  
  # Hide fill legend (keep linetype legend only)
  guides(fill = "none") +
  
  # Add plot title, subtitle, and caption
  labs(
    linetype = NULL,
    title    = "Is the temperature rising?",
    subtitle = "Average daily temperatures (Celsius) in Helsinki, 2000 vs. 2024",
    caption  = "Data: Finnish Meteorological Institute open data, weather observations (CC BY 4.0)",
    x        = NULL,
    y        = NULL
  ) +
  
  # Use a clean, minimal black-and-white theme
  theme_bw() +
  
  # Customize legend and caption styling
  theme(
    legend.direction = "horizontal",
    legend.box.background = element_rect(
      color     = "black",
      linetype  = "solid",
      linewidth = 0.5
      ),
    legend.key.size  = unit(2, "line"),
    legend.position  = c(0.83, 0.12), # bottom-right position
    legend.text      = element_text(size = 10),
    plot.caption     = element_text(size = 8, hjust = 1, color = "#777777")
  )
```

And so we have another perspective on the Helsinki temperature data set.

### Streamgraph {#sec-streamgraph}

## Bar charts {#sec-bar-charts}

### Likert chart {#sec-likert-chart}

### Mosaic chart {#sec-mosaic-chart}

## Density charts {#sec-density-charts}

### Raincloud chart {#sec-raincloud-chart}

### Ridgeline chart {#sec-ridgeline-chart}

## Geometric shapes {#sec-geometric-shapes}

### Arc {#sec-arc}

### B-spline curve {#sec-b-spline-curve}

### Bézier curve {#sec-bezier-curve}

### Circle {#sec-circle}

### Ellipse {#sec-ellipse}

## Heatmaps {#sec-heatmaps}

### Calendar heatmap {#sec-calendar-heatmap}

## Intersection diagrams {#sec-intersection-diagrams}

### UpSet diagram {#sec-upset-diagram}

### Venn diagram {#sec-venn-diagram}

## Line charts {#sec-geoms}

### Bump chart {#sec-bump-chart}

### Dumbbell and lollipop chart {#sec-dumbbell-and-lollipop-chart}

### Line chart (with neon glow or shadow effects) {#sec-line-chart-with-neon-glow-or-shadow-effects}

### Slope chart {#sec-slope-chart}

## Multivariate charts {#sec-multivariate-charts}

### Parallel coordinates chart (improved) {#sec-parallel-coordinates-chart-improved}

### Radar chart {#sec-radar-chart}

## Pie charts {#sec-pie-charts}

### Pie chart (improved) {#sec-pie-chart-improved}

### Moon chart {#sec-moon-chart}

### Square chart (waffle chart) {#sec-square-chart-waffle-chart}

## Scatter charts {#sec-scatter-charts}

### Beeswarm chart {#sec-beeswarm-chart}

### Point density chart {#sec-point-density-chart}

## Text visualization {#sec-text-visualization}

### Page layout visualization {#sec-page-layout-visualization}

### Word cloud diagram {#sec-word-cloud-diagram}

## Tree diagrams {#sec-tree-diagrams}

### Dendrogram {#sec-dendrogram}

### Treemap diagram {#sec-treemap-diagram}

### Voronoi diagram {#sec-voronoi-diagram}
