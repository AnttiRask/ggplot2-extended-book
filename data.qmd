# Data {#sec-data}

```{r}
#| echo:    false
#| message: false
#| results: asis

source("warning.R")
```

## Data sets {#sec-data-sets}

This book is about tools for creating visualizations. But to visualize data you first need data. So let's start by taking a look at some of the data sets available to us without much hassle.

### base R {#sec-base-r}

Base R comes with a bunch of data sets ready to use. There are classics like **iris** and **mtcars**, but there are many more to choose from:

```{r}
#| echo:    false
#| message: false
#| results: asis

library(dplyr)
library(purrr)
library(rmarkdown)

data() %>%
  pluck(3) %>%
  as_tibble() %>%
  filter(Package == "datasets") %>%
  select(Item, Title) %>%
  arrange(Item, .locale = "en") %>% 
  paged_table()
```

Since the **datasets** package comes from base R, the data is not always immediately ready to use with **ggplot2** [@wickham2024]. Luckily we have the **tidyverse** [@wickham2023b] packages that make it easy to make the necessary changes.

Here is an example using the **USArrests** ('Violent Crime Rates by US State') data set. We can start by loading the data set by using the `data()` function:

```{r}
data(USArrests)
```

Let's take a quick look at what the first couple of rows of the data set looks like:

```{r}
head(USArrests)
```

As you can see, USArrests is a data frame. It has four columns and the names of the US states are row names. We would like to see them as the fifth column instead. We can use the **tibble** [@müller2023] package to do that. While we're at it, let's also change the data frame into a tibble:

```{r}
library(tibble)

usarrests_tbl <- USArrests %>%
  rownames_to_column(var = "State") %>%
  as_tibble()
```

```{r}
#| echo: false
#| message: false
#| results: asis

usarrests_tbl %>%
  paged_table()
```

We can then use the new tibble to create a simple visualization with ggplot2:

```{r}
library(ggplot2)

usarrests_tbl %>%
  slice_max(Murder, n = 10) %>% 
  ggplot(aes(Murder, UrbanPop)) +
  geom_point() +
  geom_label(aes(label = State))
```

### IMDb movies (1893-2005) {#sec-imdb-movies-1893-2005}

**ggplot2movies** [@wickham2015] used to be a part of the ggplot2 package itself. It’s now its own package to make ggplot2 lighter.

But it’s a cool little package. It has [Internet Movie Database (IMDb)](https://www.imdb.com/) data about movies from between 1893 and 2005. The selected movies have "a known length and had been rated by at least one \[IMDb\] user." [@wickham2015].

The **Movies** data set has qualities that make it good for our needs. Let’s start by loading it:

```{r}
library(ggplot2movies)

data(movies)
```

Let's take a quick look at what some of the data looks like:

```{r}
#| eval: false

head(movies)
```

```{r}
#| echo: false
#| message: false
#| results: asis

head(movies) %>%
  paged_table()
```

```{r}
#| echo: false
#| message: false
#| warning: false

# Get the number of columns
.movies_ncols <- ncol(movies)

# Get the row count
.movies_rowcount <- movies %>% 
  tally()
```

Movies is already a tibble. It consists of `r .movies_rowcount` rows (observations) and `r .movies_ncols` columns (variables).

When starting to work with a new data set it's always good to take a look at the documentation. To understand what is in those rows and columns (and what is not):

```{r}
#| echo: false
#| message: false
#| results: asis

tribble(
  ~Variable,     ~Description,
  "title",       "Title of the movie",
  "year",        "Year of release",
  "budget",      "Total budget (if known) in US dollars",
  "length",      "Length in minutes",
  "rating",      "Average IMDB user rating",
  "votes",       "Number of IMDB users who rated this movie",
  "r1",          "Multiplying by ten gives percentile (to nearest 10%) of users who rated this movie a 1",
  "r2",          "Multiplying by ten gives percentile (to nearest 10%) of users who rated this movie a 2",
  "r3",          "Multiplying by ten gives percentile (to nearest 10%) of users who rated this movie a 3",
  "r4",          "Multiplying by ten gives percentile (to nearest 10%) of users who rated this movie a 4",
  "r5",          "Multiplying by ten gives percentile (to nearest 10%) of users who rated this movie a 5",
  "r6",          "Multiplying by ten gives percentile (to nearest 10%) of users who rated this movie a 6",
  "r7",          "Multiplying by ten gives percentile (to nearest 10%) of users who rated this movie a 7",
  "r8",          "Multiplying by ten gives percentile (to nearest 10%) of users who rated this movie a 8",
  "r9",          "Multiplying by ten gives percentile (to nearest 10%) of users who rated this movie a 9",
  "r10",         "Multiplying by ten gives percentile (to nearest 10%) of users who rated this movie a 10",
  "mpaa",        "MPAA rating",
  "action",      "Binary variable representing if movie was classified as belonging to that genre",
  "animation",   "Binary variable representing if movie was classified as belonging to that genre",
  "comedy",      "Binary variable representing if movie was classified as belonging to that genre",
  "drama",       "Binary variable representing if movie was classified as belonging to that genre",
  "documentary", "Binary variable representing if movie was classified as belonging to that genre",
  "romance",     "Binary variable representing if movie was classified as belonging to that genre",
  "short",       "Binary variable representing if movie was classified as belonging to that genre"
) %>%
  paged_table()
```

Here are some of the reasons why Movies is a good example data set because it includes:

-   A goldilocks amount of data. Not too little, not too much
-   *Categorical* data of both *nominal* (title, genre) and *ordinal* (mpaa) kind
-   *Numerical* data of both *continuous* (budget, length, rating) and *discrete* (year, votes) kind

We can use two of those columns, **year** and **rating** to create a simple visualization with ggplot2:

```{r}
library(ggplot2)

movies %>%
  ggplot(aes(year, rating)) +
  geom_point()
```

As mentioned earlier, Movies is already a tibble. But, it doesn't mean that the data is in an optimal format for all kinds of visualization. But we'll do all the necessary data wrangling within the chapter where we use the data.

### RDatasets {#sec-rdatasets}

[**RDatasets**](https://vincentarelbundock.github.io/Rdatasets/articles/data.html) is not an R package. But it is an excellent GitHub repo. And a “collection of datasets originally distributed in various R packages" [@arel-bundock2024].

```{r}
#| echo: false
#| message: false
#| warning: false

library(readr)
library(stringr)

# Get filename
filename <- list.files(
  path    = "data",
  pattern = "RDatasets"
)

# Extract the date
.RDatasets_date <- str_extract(filename, "\\d{4}-\\d{2}-\\d{2}")

# Get the data
.RDatasets <- read_csv2("data/RDatasets-2024-11-11.csv") %>%
  select(
    Package,
    Item,
    Title,
    Rows,
    Cols,
    n_binary,
    n_character,
    n_factor,
    n_logical,
    n_numeric
  )

# Get the row count
.RDatasets_rowcount <- .RDatasets %>% 
  tally()
```

Here listed are the `r .RDatasets_rowcount` data sets that were available on `r .RDatasets_date`:

```{r}
#| echo: false
#| message: false
#| warning: false
#| results: asis

.RDatasets %>% 
  paged_table()
```

The RDatasets repo contains that same list. But there you will also find a .csv file and documentation for each data set.

If I had to choose one fun data set from the list to highlight, it would be **starwars** from the **dplyr** [@wickham2023c] package.

You can choose to use the .csv file provided on the website. Another way to use the collection is to choose the dataset from the list and load the package it comes with:

```{r}
library(dplyr)

data(starwars)
```

Let's take a quick look at what some of the starwars data looks like:

```{r}
#| eval: false

head(starwars)
```

```{r}
#| echo: false
#| message: false
#| results: asis

head(starwars) %>%
  paged_table()
```

There are a bunch of Star Wars characters and their stats.

Let's choose two columns, **height** and **species** (and filter for six of the more well-known species). We'll use them to create a simple visualization with ggplot2:

```{r}
#| message: false
#| warning: false
#| results: asis

library(ggplot2)

starwars %>%
  filter(species %in% c("Droid", "Ewok", "Gungan", "Human", "Hutt", "Wookiee")) %>%
  ggplot(aes(height, species)) +
  geom_boxplot()
```

This concludes the section about the different data sets available for every R user. Next, we'll take a look at some of the ggplot2 extensions that make it easier to do exploratory data analysis (EDA).

## Exploratory data analysis (EDA) {#sec-exploratory-data-analysis-eda}

Exploratory data analysis (or EDA, which we'll be using from now on) is a process, even if it is a loose one. The Cambridge Dictionary [@mcintosh2013] defines process as "a series of actions that you take in order to achieve a result". So, we a) have a series of actions and b) a result you wish to achieve.

Let's look at the results first. After all, that is why we do things. You might have other, more specific goals depending on your particular field or use case. But in the most general sense, the result we're after is a better understanding of the data (set) we're working on.

What are the series of actions we need to take? As I mentioned earlier, EDA is a loose process. There are as many ways to go about it as there are analysts and data sets. Still, some common steps usually occur: looking at **missing values**, **summarizing data**, and **visualizing relationships** between variables.

It's good to note these visualizations aren't usually meant for publication. Compared to those you find later on in the book, these are more for your eyes than for the eventual audience.

The last thing we'll look at in this chapter is one way to **automate** the EDA process using an app. Although I must warn you. It's better to use these tools only after you've gained experience from doing EDA without them. It might sound counterintuitive, but trust me. It can be too overwhelming if you don't know what you're doing.

### Missing values {#sec-missing-values}

Let's first load the data. Looking at the movies data set earlier we noticed the **mpaa** column had many blank values. We don't know if they didn't have a rating in the first place. Or if they did, but the rating is missing. For the sake of this demonstration, let's assume they all should have a rating.

We'll begin by turning all the blank values (of the *character* type) into *NA* (not available).

```{r}
#| message: false
#| warning: false

library(dplyr)
library(ggplot2movies)

movies_na <- movies %>%
  mutate(
    # Turn all blank values of the character type into NA
    across(where(is.character), ~na_if(., "")), 
    # Create a decade column based on the values in the year column
    decade = floor(year / 10) * 10
  )
```

**Naniar** [@tierney2024] is a package with many functions for visualizing missing (NA) values. It does contain many functions outside of visualization. But that's for another book.

One simple function is `gg_miss_var()`. It creates a lollipop plot (\[INSERT LINK HERE\]). It shows which columns (variables) contain the greatest amount of missing (NA) values.

```{r}
library(naniar)

movies_na %>% 
  gg_miss_var()
```

We can see that _MPAA ratings_ aren't the only thing missing. Almost the same amount of films are missing the budget information. With budget, it's easier to say that if we don't have a number, it is missing. Then again, that column did have NAs in place from the beginning.

We're also interested in seeing if there is overlapping *missingness* between the columns. We'll use an upset plot (\[INSERT LINK HERE\]) for that. Just add `gg_miss_upset()`.

```{r}
movies_na %>% 
  gg_miss_upset(
    # Number of sets to look at. We know there are only two columns with NA
    nsets = 2 
  )
```

More than 3000 movies without an MPAA rating and almost the same amount without a budget. But over 50000 without both. That makes me think there is a consistency in the missingness.

We can also use `geom_miss_point()` to see if there are more patterns between the missing variables. Let's also use `label_number()` from the **scales** [@wickham2023e] package to prettify the x-axis labels.

```{r}
#| message: false
#| warning: false

library(ggplot2)
library(scales)

p <- movies_na %>%
  ggplot(aes(budget, mpaa)) +
  geom_point() +
  geom_miss_point() +
  scale_x_continuous(
    labels = label_number(
      scale  = 1e-6,
      prefix = "$",
      suffix = "M"
    )
  )
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| results: asis

p
```

Values seem to be missing in all the MPAA rating categories. NC-17 does not seem to contain that many values in general, but many of them seem to be missing.

Let's confirm this observation by creating a frequency table with the `tabyl()` function. It's from a neat package called **janitor** [@firke2023].

```{r}
#| message: false
#| warning: false
#| results: asis

library(janitor)

movies_na %>% 
  filter(mpaa == "NC-17") %>% 
  tabyl(mpaa, budget) %>%
  paged_table()
```

So, there are more NC-17 movies that are missing the budget than those that aren't.

We can dig even deeper. We can use `facet_wrap()` from ggplot2 to see how the missing values are distributed throughout the history.

```{r}
#| message: false
#| warning: false
#| results: asis

p +
  scale_x_continuous(
    n.breaks = 3,
    labels   = label_number(
      scale  = 1e-6,
      prefix = "$",
      suffix = "M"
    )
  ) +
  facet_wrap(vars(decade))
```

Before moving on, let's first look at one interesting alternative for visualizing missing values: `plot_missing()`. It comes from the __DataExplorer__ [@cui2024] package.

```{r}
#| message: false
#| warning: false
#| results: asis

library(DataExplorer)

movies_na %>%
  # Let's only visualize the missing values
  plot_missing(missing_only = TRUE)
```

You see the amount and percentage of NAs per column, arranged in order of missingness. This is a great quick overview!

DataExplorer, like naniar earlier, provides functions for handling the missing values. For instance, we could drop the __budget__ and __mpaa__ columns, as indicated by the red color in the visualization above.

### Summarizing data {#sec-summarizing-data}

Of course, we want to visualize more than just the missing data. It makes sense to start with an overview of some kind.

### Visualizing relationships {#sec-visualizing-relationships}

**Pairwise plot matrix**

**Correlation matrix**

### Automated EDA app {#sec-automated-eda-app}
